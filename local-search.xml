<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/04/14/Pwn%E7%AC%94%E8%AE%B0%20%E9%A2%98%E7%9B%AE%E7%9A%84docker%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/04/14/Pwn%E7%AC%94%E8%AE%B0%20%E9%A2%98%E7%9B%AE%E7%9A%84docker%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>根据助教老师的提示，使用ctf_xinetd框架</p><p>使用README.md中的方法，无法复现：原可执行程序的功能是打印”Hello ctf_xinetd”之后开shell，但是开容器后，用nc连接时没有Hello信息，可以正常开shell。</p><p>执行exit无法直接退出，反而打印了Hello信息。然后多次键入回车后会退出。推测多次键入回车是退出时的确认。</p><p>因此将打印信息删除了，直接进行注入和执行。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/04/13/Pwn%E7%AC%94%E8%AE%B0%20shellcode%E7%9A%84%E6%9E%84%E5%BB%BA/"/>
    <url>/2022/04/13/Pwn%E7%AC%94%E8%AE%B0%20shellcode%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>32位shellcode:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs assembly">xor    ecx,ecx;<br>mul    ecx;<br>push   ecx;<br>push   0x68732f2f;<br>push   0x6e69622f;<br>mov    ebx,esp;<br>mov    al,0xb;<br>int    0x80;<br></code></pre></td></tr></table></figure><p>32位机器的系统调用，调用号在EAX，前面的参数依次在EBX, ECX, EDX</p><p>其中，<code>mul ecx;</code>指令的作用为<code>EDX:EAX &lt;-- EAX * r/m32</code>，将EDX和EAX清零。</p><p>64位shellcode：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">xor     rdx, rdx<br>mov     qword rbx, &#x27;//bin/sh&#x27;<br>shr     rbx, 0x8<br>push    rbx<br>mov     rdi, rsp<br>push    rax<br>push    rdi<br>mov     rsi, rsp<br>mov     al, 0x3b<br>syscall<br></code></pre></td></tr></table></figure><p>64位机器系统调用，调用号在RAX，前面的参数依次在RDI, DSI, RDX, RCX</p><p>假设开始时rax为零了</p><p>且rcx为零不需要保证</p><p>使用pwntools可以把其中的AT&amp;T转换成intel风格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理记录：基于LLVM/Clang编译器使用及编译方案优化</title>
    <link href="/2022/04/12/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%9F%BA%E4%BA%8ELLVMClang%E7%BC%96%E8%AF%91%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%BC%96%E8%AF%91%E6%96%B9%E6%A1%88%E4%BC%98%E5%8C%96/"/>
    <url>/2022/04/12/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%9F%BA%E4%BA%8ELLVMClang%E7%BC%96%E8%AF%91%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%BC%96%E8%AF%91%E6%96%B9%E6%A1%88%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>本学期的编译原理课程有一个关于<code>LLVM/Clang</code>环境的搭建和优化的作业，要求在原始编译器的基础上扩展数组类型修饰符，增加越界访问检查功能。这个内容正好对于系统安全来说比较重要(至少大创老师是这么说的)，因此进行一些记录。</p><p>在gitlab上建了一个project，地址也贴在这里：<a href="https://gitlab.com/Non1187/compileprinciplelab-2022-spring">Non &#x2F; CompilePrincipleLab-2022-spring · GitLab</a></p><h4 id="Lab1-分析"><a href="#Lab1-分析" class="headerlink" title="Lab1 分析"></a>Lab1 分析</h4><p>由于组内ly同学的出色表现，Lab1-1基本已经宣告完成了(即基本完成了<code>*.g4</code>的编写)，我需要完成的实验部分就是Lab1-2了。思路是，首先尝试熟悉C++语法并完成初步的代码分析，然后进行代码的编写。</p><h5 id="Context对象的结构"><a href="#Context对象的结构" class="headerlink" title="Context对象的结构"></a>Context对象的结构</h5><p>根据<code>Lab1-2.md</code>，代码实现过程中对<code>Context</code>对象的结构了解很重要，首先需要查看<code>SafeCParser.h</code>中的结构定义。</p><p><code>AstBuilder.cpp</code>中的 <code>AstBuilder::visitCompUnit()</code>方法参数中有CompUnitContext指针类型的变量<code>ctx</code>，进行trace可以追踪到SafeCParser.h中的一个类。类定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span>  <span class="hljs-title class_">CompUnitContext</span> : <span class="hljs-keyword">public</span> antlr4::ParserRuleContext &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CompUnitContext</span>(antlr4::ParserRuleContext *parent, <span class="hljs-type">size_t</span> invokingState);<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">size_t</span> <span class="hljs-title">getRuleIndex</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>  antlr4::<span class="hljs-function">tree::TerminalNode *<span class="hljs-title">EOF</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function">std::vector&lt;DeclContext *&gt; <span class="hljs-title">decl</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function">DeclContext* <span class="hljs-title">decl</span><span class="hljs-params">(<span class="hljs-type">size_t</span> i)</span></span>;<br>  <span class="hljs-function">std::vector&lt;FuncDefContext *&gt; <span class="hljs-title">funcDef</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function">FuncDefContext* <span class="hljs-title">funcDef</span><span class="hljs-params">(<span class="hljs-type">size_t</span> i)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> antlrcpp::Any <span class="hljs-title">accept</span><span class="hljs-params">(antlr4::tree::ParseTreeVisitor *visitor)</span> <span class="hljs-keyword">override</span></span>;<br> <br>&#125;;<br></code></pre></td></tr></table></figure><p>继承了<code>ParserRuleContext.h</code>中名字空间<code>antlr4</code>内的类<code>ParserRuleContext</code>。同名方法<code>CompUnitContext</code>，功能是使用<code>this</code>指针初始化；定义了两个指针向量容器<code>decl</code>和<code>funcDef</code>，以及两个指针<code>decl</code>和<code>funcDef</code>。指针指向的类型都是形如<code>DeclContext</code> <code>FuncDefContext</code>的环境类型。类似地分析，此时<code>Context</code>之间构成了一个树的结构，并且结构与<code>g4</code>文件中的定义相同。</p><hr><p>还需要分析<code>Context</code>对象在<code>visitCompUnit</code>方法中的作用，考虑<code>visitCompUnit</code>方法的内容。</p><p><code>main.cpp</code>中，调用<code>parser.compUnit()</code>方法，该方法返回一个<code>CompUnitContext *_localctx</code>环境对象。以该对象作为参数，调用<code>AstBuilder ast_builder</code>类初始化方法即<code>visit()</code>方法，<code>visit()</code>方法中调用该节点的<code>tree-&gt;accept(this)</code>方法。</p><p><code>accept</code>方法，功能为调用该节点的<code>visit(*this)</code>方法。<code>visit()</code>方法中又对每个子节点调用本节点的<code>accept()</code>方法。</p><p><code>accept()</code>方法定义在文件<code>SafeCParser.cpp</code>中。其中可以调用<code>visitor -&gt; visitChildren(this)</code>对子节点进行访问。</p><hr><p>在上面对<code>Context</code>对象的分析的基础上，考虑<code>AstBuilder.cpp</code>中，对语法分析树的操作是如何嵌入的。</p><p><code>AstBuilder.cpp</code>中，对语法分析树的操作 实现在<code>visitCompUnit()</code> <code>visitDecl()</code> <code>visitFuncDef()</code>等方法中，这些visit方法会在accept函数中使用，从而对节点进行操作。</p><h5 id="AstBuilder类方法的编写"><a href="#AstBuilder类方法的编写" class="headerlink" title="AstBuilder类方法的编写"></a>AstBuilder类方法的编写</h5><p>推测：AstBuilder类方法的功能，是根据语法分析树给出的<code>Context *ctx</code>得到对应的<code>ast_node</code>结构体，并且需要通过指针将结构体相连接。</p><p>今天3&#x2F;22又看了看，发现之前对AST的理解有些浅显。AST中实际上可以包含很多类型的结点，而不仅仅是+-之类的运算符。</p><p>3&#x2F;22，再次编译时发现竟然出现和英杰一样的错误，可能是将git换成了https导致的，但是几率应该不大。</p><p>3&#x2F;22，晚上和ly头脑风暴了一轮，我贡献了VSCode编写方法，ly则已经有了比较清晰的框架，一起基本确定了<code>AstBuilder.cpp</code>的编写方法。</p><p>3&#x2F;25，再次出现编译中git clone慢的问题，昨晚找ly问了问这个问题，需要先在<code>/etc/hosts</code>中添加下述项：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">192.30.255.112  github.com git<br>185.31.16.184   github.global.ssl.fastly.net<br></code></pre></td></tr></table></figure><p>第一行应该与git命令有关，第二行好像是设置了一个全局的ssl连接的域名解析IP(两个IP之前都还没见过)</p><p>然后使用<code>git config --global --edit</code>，将之前的config全部删除(遗留下来的没用的操作)。之后今天就可以正常编译了。</p><p>编写时需要使用的语法：</p><p>​        从<code>context</code>转换到<code>ptr&lt;node&gt;</code>，使用<code>reset(visit(ctx).as&lt;node *&gt;())</code>方法。<code>visit(ctx).as&lt;node *&gt;()</code>得到<code>node</code>类型，之后可以用<code>reset()</code>转换为对应的<code>ptr</code>类型，或直接用<code>ptr&lt;***node&gt;()</code>转换为对应父类的<code>ptr</code>类型。</p><p>​    <code>visit(ctx).as&lt;node *&gt;</code>中，<code>node</code>的类型不是和context一一对应的（也有可能需要转换成其他的类型）。</p><p>​    进行转换时，深度上基本严格按照SafeCParser.g4的文件编写即可，不需要尝试多写几层到非终结符</p><p>​    转换时，对SafeCParser.g4中的选择的情况，可以直接根据不同的选择再声明result</p><p>​    对于类似产生式的多个选择的情况，分类时以AstNode的类别为准，但可能与SafeCParser.h中的语法规则有一定区别。即，不需要为每一个visit函数定义一个node，可以直接返回。</p><p>​    visit产生所有结点后，程序会利用节点的内容关系进行遍历，因此重视的应该是节点之间的关系，而非visit的过程</p><p>3&#x2F;30</p><p>初步编写完成，可以正常编译，运行时出现segmentation fault。</p><p>找助教解决了编译的问题，换了一个更好的源，编译速度加快。</p><p>3&#x2F;31</p><p>补充，一次编译后build文件夹不要删除，应留着下次编译直接用，加快编译速度。</p><p>4&#x2F;3</p><p>进行diff测试，需要修改的：</p><p>​    SafeCParser.g4 </p><p>​            * block中使用blockItem</p><p>​    AstBuilder.cpp</p><p>​            visitArray中array_length需要初始化，若没有数值则初始化为数组长度</p><p>​            visitArray中的initializers不使用var_def_initializers, 使用array_initializers</p><p>4&#x2F;12  实验课</p><p>​    关于dynamic&#x2F;static_cast，</p><p>​            dynamic_cast会在运行时进行检查，static_cast不会检查</p><p>​            父类转子类是不安全的，需要是原生的才能转换。因此需要使用dynamic_cast进行转换。</p><p>​    调试时，发生abort等 可以用bt</p><p>​    <em>！！</em>为保证访问者模式的规范，visit函数中返回的node类型尽量是一样的</p><h4 id="Lab2-分析"><a href="#Lab2-分析" class="headerlink" title="Lab2  分析"></a>Lab2  分析</h4><h5 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h5><p>LLVM IR介绍，Instruction大部分是3地址码的形式。</p><p>LLVM IR生成</p><p>已经通过ANTLR收集到了前端信息，</p><p>Lab2实验内容</p><p>检查的情况：包括，obc数组的情况，定义时size是2但是实际分量数量是4的情况。</p><p>先给的fib数组分量有限，</p><p>前期要做实验先了解LLVM的IR</p><p>演示，写了一个check的源代码，IR生成，修改arrlen，若越界触发问题</p>]]></content>
    
    
    <categories>
      
      <category>课程随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UCASCheer</title>
    <link href="/2022/03/03/UCASCheer/"/>
    <url>/2022/03/03/UCASCheer/</url>
    
    <content type="html"><![CDATA[<p>Welcome to UCASCheer!</p><p>刚学会搭建网站，初来乍到请谅解。 后期本人会努力进行一些优化的</p><p>譬如首页的打印机招牌，正在思考修改或去掉的方案（</p><p>感谢浏览本站！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
