<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/03/15/3%E6%9C%8815%20%E6%84%9F%E6%83%B3/"/>
    <url>/2022/03/15/3%E6%9C%8815%20%E6%84%9F%E6%83%B3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>软件安全记录：shellcode的调试</title>
    <link href="/2022/03/10/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E8%AE%B0%E5%BD%95%EF%BC%9Ashellcode%E7%9A%84%E8%B0%83%E8%AF%95/"/>
    <url>/2022/03/10/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E8%AE%B0%E5%BD%95%EF%BC%9Ashellcode%E7%9A%84%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>软件漏洞课上要做实验，在64位Seed Ubuntu20.04中搞了个32位的程序，加上了32位shellcode尝试getshell，但是结果不符合预期：</p><p>在gdb中运行：</p><ul><li>不使用set follow-fork-mode parent，报错，直接退出gdb</li><li>使用set follow-fork-mode parent，可以正常getshell</li></ul><p>直接运行，则报segmentation fault</p><p>本来其实也不是很想接着搞了，因为上课的时候，陈恺老师遇到这种问题一般就随口提一下，让我们自己尝试探究探究，不会有更进一步的反馈。这样的想法不是很好</p>]]></content>
    
    
    <categories>
      
      <category>课程随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理记录：LLVM编译器使用及编译方案优化</title>
    <link href="/2022/03/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AE%B0%E5%BD%95%EF%BC%9ALLVM%E7%BC%96%E8%AF%91%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%BC%96%E8%AF%91%E6%96%B9%E6%A1%88%E4%BC%98%E5%8C%96/"/>
    <url>/2022/03/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AE%B0%E5%BD%95%EF%BC%9ALLVM%E7%BC%96%E8%AF%91%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%BC%96%E8%AF%91%E6%96%B9%E6%A1%88%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>本学期的编译原理课程有一个关于<code>LLVM/Clang</code>环境的搭建和优化的作业，要求在原始编译器的基础上扩展数组类型修饰符，增加越界访问检查功能。这个内容正好对于系统安全来说比较重要(至少大创老师是这么说的)，因此进行一些记录。</p><p>在gitlab上建了一个project，地址也贴在这里：<a href="https://gitlab.com/Non1187/compileprinciplelab-2022-spring">Non &#x2F; CompilePrincipleLab-2022-spring · GitLab</a></p><h4 id="Lab1-2-分析"><a href="#Lab1-2-分析" class="headerlink" title="Lab1-2 分析"></a>Lab1-2 分析</h4><p>由于组内ly同学的出色表现，Lab1-1基本已经宣告完成了(即基本完成了<code>*.g4</code>的编写)，我需要完成的实验部分就是Lab1-2了。思路是，首先尝试熟悉C++语法并完成初步的代码分析，然后进行代码的编写。</p><h5 id="Context对象的结构"><a href="#Context对象的结构" class="headerlink" title="Context对象的结构"></a>Context对象的结构</h5><p>根据<code>Lab1-2.md</code>，代码实现过程中对<code>Context</code>对象的结构了解很重要，首先需要查看<code>SafeCParser.h</code>中的结构定义。</p><p><code>AstBuilder.cpp</code>中的 <code>AstBuilder::visitCompUnit()</code>方法参数中有CompUnitContext指针类型的变量<code>ctx</code>，进行trace可以追踪到SafeCParser.h中的一个类。类定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span>  <span class="hljs-title class_">CompUnitContext</span> : <span class="hljs-keyword">public</span> antlr4::ParserRuleContext &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CompUnitContext</span>(antlr4::ParserRuleContext *parent, <span class="hljs-type">size_t</span> invokingState);<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">size_t</span> <span class="hljs-title">getRuleIndex</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>  antlr4::<span class="hljs-function">tree::TerminalNode *<span class="hljs-title">EOF</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function">std::vector&lt;DeclContext *&gt; <span class="hljs-title">decl</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function">DeclContext* <span class="hljs-title">decl</span><span class="hljs-params">(<span class="hljs-type">size_t</span> i)</span></span>;<br>  <span class="hljs-function">std::vector&lt;FuncDefContext *&gt; <span class="hljs-title">funcDef</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function">FuncDefContext* <span class="hljs-title">funcDef</span><span class="hljs-params">(<span class="hljs-type">size_t</span> i)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> antlrcpp::Any <span class="hljs-title">accept</span><span class="hljs-params">(antlr4::tree::ParseTreeVisitor *visitor)</span> <span class="hljs-keyword">override</span></span>;<br> <br>&#125;;<br></code></pre></td></tr></table></figure><p>继承了<code>ParserRuleContext.h</code>中名字空间<code>antlr4</code>内的类<code>ParserRuleContext</code>。同名方法<code>CompUnitContext</code>，功能是使用<code>this</code>指针初始化；定义了两个指针向量容器<code>decl</code>和<code>funcDef</code>，以及两个指针<code>decl</code>和<code>funcDef</code>。指针指向的类型都是形如<code>DeclContext</code> <code>FuncDefContext</code>的环境类型。类似地分析，此时<code>Context</code>之间构成了一个树的结构，并且结构与<code>g4</code>文件中的定义相同。</p><hr><p>还需要分析<code>Context</code>对象在<code>visitCompUnit</code>方法中的作用，考虑<code>visitCompUnit</code>方法的内容。</p><p><code>main.cpp</code>中，调用<code>parser.compUnit()</code>方法，该方法返回一个<code>CompUnitContext *_localctx</code>环境对象。以该对象作为参数，调用<code>AstBuilder ast_builder</code>类初始化方法即<code>visit()</code>方法，<code>visit()</code>方法中调用该节点的<code>tree-&gt;accept(this)</code>方法。</p><p><code>accept</code>方法，功能为调用该节点的<code>visit(*this)</code>方法。<code>visit()</code>方法中又对每个子节点调用本节点的<code>accept()</code>方法</p><p>有没有<code>AstNode.cpp </code>?</p>]]></content>
    
    
    <categories>
      
      <category>课程随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UCASCheer</title>
    <link href="/2022/03/03/UCASCheer/"/>
    <url>/2022/03/03/UCASCheer/</url>
    
    <content type="html"><![CDATA[<p>Welcome to UCASCheer!</p><p>刚学会搭建网站，初来乍到请谅解。 后期本人会努力进行一些优化的</p><p>譬如首页的打印机招牌，正在思考修改或去掉的方案（</p><p>感谢浏览本站！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
